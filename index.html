<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Safe The Uyghurs</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #111;
            font-family: 'Press Start 2P', cursive;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        canvas {
            display: block;
            margin: 0 auto;
            background-color: #dcb159;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        /* --- UI LAYER --- */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; z-index: 5;
        }

        #top-ui {
            padding: 15px; display: flex; justify-content: space-between;
            color: #fff; text-shadow: 2px 2px 0 #000; font-size: 14px;
        }

        /* --- SCREENS --- */
        #start-screen, #game-over-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(18, 24, 33, 0.98);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white; z-index: 10; pointer-events: auto; text-align: center;
        }

        h1 { 
            font-size: 24px; color: #ffcc00; margin-bottom: 5px; 
            text-shadow: 4px 4px 0 #8b0000; line-height: 1.5;
        }
        
        .mode-container {
            display: flex; flex-direction: column; gap: 20px; 
            margin-top: 25px; width: 80%; max-width: 300px;
            align-items: center;
        }

        .mode-card {
            border: 2px solid #555; background: #222; padding: 10px; width: 100%;
            cursor: pointer; transition: all 0.1s; 
            display: flex; flex-direction: row; align-items: center; gap: 15px;
            border-radius: 8px; text-align: left;
        }

        .mode-card:active { border-color: #ffcc00; background: #333; transform: scale(0.98); }
        
        .mode-info { display: flex; flex-direction: column; }
        .mode-title { font-size: 12px; color: #fff; margin-bottom: 5px; color: #ffcc00; }
        .mode-desc { font-size: 8px; color: #aaa; line-height: 1.4; }

        .btn {
            background: #d32f2f; border: 4px solid #fff; padding: 15px 30px;
            color: white; font-family: 'Press Start 2P'; font-size: 16px; cursor: pointer; margin-top: 20px;
        }

        /* --- CONTROLS --- */
        .controls-hint {
            display: flex; width: 100%; height: 200px; pointer-events: none;
            position: absolute; bottom: 0;
        }
        .left-control { width: 50%; pointer-events: auto; }
        .right-control { width: 50%; pointer-events: auto; position: relative; }

        .game-btn {
            border-radius: 50%; border: 3px solid rgba(255,255,255,0.9); 
            background: rgba(0,0,0,0.4); color: white;
            display: flex; align-items: center; justify-content: center;
            font-size: 24px; position: absolute; touch-action: manipulation;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }
        .game-btn:active { background: rgba(255,255,255,0.4); transform: scale(0.95); }

        #btn-flash { width: 85px; height: 85px; right: 40px; bottom: 50px; background: rgba(255, 255, 255, 0.1); }
        #btn-kick { width: 75px; height: 75px; right: 20px; bottom: 100px; background: rgba(200, 50, 50, 0.3); font-size: 20px;}
        #btn-grab { width: 75px; height: 75px; right: 100px; bottom: 30px; background: rgba(50, 50, 200, 0.3); font-size: 20px;}

        .hidden { display: none !important; }
        
        #joystick-ui {
            position: absolute; width: 100px; height: 100px;
            border: 2px solid rgba(255,255,255,0.3); border-radius: 50%;
            display: none; pointer-events: none;
        }
        #joystick-stick {
            position: absolute; width: 40px; height: 40px;
            background: rgba(255,255,255,0.5); border-radius: 50%; top: 30px; left: 30px;
        }

    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="top-ui">
            <span id="score-label">SCORE: <span id="score-val">0</span></span>
        </div>
        
        <div id="joystick-ui"><div id="joystick-stick"></div></div>

        <div class="controls-hint">
            <div class="left-control" id="joystick-zone"></div>
            <div class="right-control">
                <div id="btn-flash" class="game-btn hidden" ontouchstart="doAction('flash', event)">üì∏</div>
                <div id="btn-kick" class="game-btn hidden" ontouchstart="doAction('kick', event)">üèè</div>
                <div id="btn-grab" class="game-btn hidden" ontouchstart="doAction('grab', event)">‚úã</div>
            </div>
        </div>
    </div>

    <div id="start-screen">
        <h1>SAFE THE<br>UYGHURS</h1>
        <p style="font-size: 10px; color: #aaa; margin-bottom: 20px;">SELECT MODE</p>
        
        <div class="mode-container">
            <div class="mode-card" onclick="setMode('whistleblower')">
                <canvas id="p1-canvas" width="60" height="60"></canvas>
                <div class="mode-info">
                    <div class="mode-title">WHISTLEBLOWER</div>
                    <div class="mode-desc">Reveal the truth.<br>Do not get caught.</div>
                </div>
            </div>
            <div class="mode-card" onclick="setMode('perpetrator')">
                <canvas id="p2-canvas" width="60" height="60"></canvas>
                <div class="mode-info">
                    <div class="mode-title">PERPETRATOR</div>
                    <div class="mode-desc">Guard the camp.<br>Stop the leaks.</div>
                </div>
            </div>
        </div>
    </div>

    <div id="game-over-screen" style="display: none;">
        <h1 id="go-title" style="color: #ff5555">GAME OVER</h1>
        <p id="go-reason" style="font-size: 12px; margin-bottom: 20px;">...</p>
        <p>Final Score: <span id="final-score" style="color:#ffcc00">0</span></p>
        <button class="btn" onclick="showStartScreen()">MAIN MENU</button>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // --- ASSETS & CONFIG ---
    const C = {
        sand: '#e0cda6', sandDetail: '#d0bd96',
        wall: '#525b68', door: '#2b2b2b', wire: '#111',
        skin: '#f5cba7',
        wbBlue: '#3498db',
        swatBlack: '#1e272e', swatRed: '#c0392b',
        flashColor: 'rgba(255, 255, 255, 0.85)'
    };

    const WIRE_Y = 130; // The hard border

    // --- STATE ---
    let GAME_MODE = 'whistleblower';
    let gameActive = false;
    let frame = 0;
    let score = 0;
    let cooldown = 0;
    
    let hero = { 
        x: 0, y: 0, speed: 4, hp: 100, 
        angle: -Math.PI/2, // Aim angle
        facing: 1, // 1 = Right, -1 = Left (Side view)
        state: 'idle', 
        holding: null,
        flashTimer: 0,
        swingTimer: 0
    };
    
    let entities = [];
    let items = [];
    let particles = [];
    let floatTexts = [];

    let joystick = { on: false, id: null, sx: 0, sy: 0, cx: 0, cy: 0 };

    // --- PORTRAITS (PIXEL ART) ---
    function drawPixelFace(ctx, type) {
        ctx.clearRect(0,0,60,60);
        const w=5, h=5; // pixel size
        // Simple data visualizer for faces
        // 0:empty, 1:skin, 2:hair/black, 3:blue/acc, 4:red
        let map = [];
        if(type==='wb') {
            map = [
                0,0,2,2,2,2,2,0,
                0,2,2,2,2,2,2,2,
                0,2,2,1,1,1,2,2,
                0,2,1,1,1,1,1,2,
                0,2,1,2,1,2,1,2,
                0,2,1,1,1,1,1,2,
                0,2,1,1,1,1,1,2,
                0,0,3,3,3,3,3,0
            ];
        } else {
            map = [
                0,2,2,2,2,2,2,0,
                0,2,2,2,2,2,2,0,
                0,2,2,4,4,4,2,0,
                0,2,2,4,4,4,2,0,
                0,2,2,2,2,2,2,0,
                0,0,2,2,2,2,0,0,
                0,0,2,2,2,2,0,0,
                0,0,2,2,2,2,0,0
            ];
        }
        
        ctx.save();
        ctx.translate(10, 10);
        for(let r=0; r<8; r++) {
            for(let c=0; c<8; c++) {
                let val = map[r*8+c];
                if(val!==0) {
                    if(val===1) ctx.fillStyle = C.skin;
                    if(val===2) ctx.fillStyle = '#111';
                    if(val===3) ctx.fillStyle = C.wbBlue;
                    if(val===4) ctx.fillStyle = '#f00';
                    ctx.fillRect(c*w, r*h, w, h);
                }
            }
        }
        ctx.restore();
    }

    function initPortraits() {
        drawPixelFace(document.getElementById('p1-canvas').getContext('2d'), 'wb');
        drawPixelFace(document.getElementById('p2-canvas').getContext('2d'), 'swat');
    }
    setTimeout(initPortraits, 100);

    // --- CONTROLS ---
    const joyZone = document.getElementById('joystick-zone');
    const joyUI = document.getElementById('joystick-ui');
    const joyStick = document.getElementById('joystick-stick');

    joyZone.addEventListener('touchstart', e => {
        e.preventDefault();
        let t = e.changedTouches[0];
        joystick.on = true; joystick.id = t.identifier;
        joystick.sx = t.clientX; joystick.sy = t.clientY;
        joystick.cx = t.clientX; joystick.cy = t.clientY;
        joyUI.style.display = 'block';
        joyUI.style.left = (t.clientX - 50) + 'px';
        joyUI.style.top = (t.clientY - 50) + 'px';
        joyStick.style.left = '30px'; joyStick.style.top = '30px';
    }, {passive:false});

    joyZone.addEventListener('touchmove', e => {
        e.preventDefault();
        for(let t of e.changedTouches) {
            if(joystick.on && t.identifier === joystick.id) {
                joystick.cx = t.clientX; joystick.cy = t.clientY;
                let dx = t.clientX - joystick.sx;
                let dy = t.clientY - joystick.sy;
                let dist = Math.min(Math.sqrt(dx*dx + dy*dy), 30);
                let angle = Math.atan2(dy, dx);
                joyStick.style.left = (30 + Math.cos(angle)*dist) + 'px';
                joyStick.style.top = (30 + Math.sin(angle)*dist) + 'px';
            }
        }
    }, {passive:false});

    joyZone.addEventListener('touchend', e => {
        e.preventDefault();
        for(let t of e.changedTouches) {
            if(joystick.on && t.identifier === joystick.id) {
                joystick.on = false; joyUI.style.display = 'none';
            }
        }
    }, {passive:false});

    window.addEventListener('keydown', e => {
        if(e.code==='Space') {
            if(GAME_MODE==='whistleblower') doAction('flash');
            else doAction('kick');
        }
        if(e.code==='ShiftLeft' && GAME_MODE==='perpetrator') doAction('grab');
    });

    // --- LOGIC ---
    function setMode(mode) {
        GAME_MODE = mode;
        const btnFlash = document.getElementById('btn-flash');
        const btnKick = document.getElementById('btn-kick');
        const btnGrab = document.getElementById('btn-grab');

        if(mode === 'whistleblower') {
            btnFlash.classList.remove('hidden');
            btnKick.classList.add('hidden');
            btnGrab.classList.add('hidden');
        } else {
            btnFlash.classList.add('hidden');
            btnKick.classList.remove('hidden');
            btnGrab.classList.remove('hidden');
        }
        startGame();
    }

    function showStartScreen() {
        document.getElementById('start-screen').style.display = 'flex';
        document.getElementById('game-over-screen').style.display = 'none';
        gameActive = false;
    }

    function startGame() {
        document.getElementById('start-screen').style.display = 'none';
        document.getElementById('game-over-screen').style.display = 'none';
        
        hero.x = canvas.width/2;
        hero.y = canvas.height - 150;
        hero.hp = 100;
        hero.angle = -Math.PI/2;
        hero.holding = null;
        
        entities = [];
        items = [];
        particles = [];
        floatTexts = [];
        score = 0;
        frame = 0;
        gameActive = true;
        
        loop();
    }

    function loop() {
        if(!gameActive) return;
        update();
        draw();
        frame++;
        requestAnimationFrame(loop);
    }

    function update() {
        if(cooldown > 0) cooldown--;
        if(hero.flashTimer > 0) hero.flashTimer--;
        if(hero.swingTimer > 0) hero.swingTimer--;

        // Movement
        let dx = 0, dy = 0;
        if(joystick.on) {
            dx = joystick.cx - joystick.sx;
            dy = joystick.cy - joystick.sy;
            if(Math.sqrt(dx*dx + dy*dy) > 10) {
                hero.angle = Math.atan2(dy, dx);
                let spd = hero.holding ? hero.speed * 0.5 : hero.speed;
                hero.x += Math.cos(hero.angle) * spd;
                hero.y += Math.sin(hero.angle) * spd;
                hero.state = 'run';
                
                // Set Visual Facing based on aim angle
                // If angle is to the left (90 to 270 degrees), face left
                if (Math.abs(hero.angle) > Math.PI / 2) hero.facing = -1;
                else hero.facing = 1;

            } else { hero.state = 'idle'; }
        } else { hero.state = 'idle'; }

        // --- COLLISIONS & BOUNDARIES ---
        
        // 1. Screen edges
        hero.x = Math.max(20, Math.min(canvas.width - 20, hero.x));
        hero.y = Math.min(canvas.height - 20, hero.y);

        // 2. Barbed Wire Logic
        let wireLimit = WIRE_Y; 
        
        if (GAME_MODE === 'whistleblower') {
            // Whistleblower CANNOT pass wire
            if (hero.y < wireLimit) hero.y = wireLimit;
        } else {
            // Perpetrator logic
            // Only can pass if holding someone in the center area
            if(hero.holding && Math.abs(hero.x - canvas.width/2) < 50) {
                // Allow entry
                if (hero.y < 80) { // Deep inside
                    spawnFloatText(hero.x, hero.y, "+1", "#fff");
                    score += 1;
                    hero.holding.dead = true;
                    hero.holding = null;
                    hero.y = wireLimit + 10; // Auto exit
                }
            } else {
                // Block if not holding or not in center
                if (hero.y < wireLimit) hero.y = wireLimit;
            }
        }

        // --- ENTITIES ---
        if(frame % 110 === 0) spawnEntity('civ');
        
        // Difficulty Logic (Perp mode easier now)
        let rate = GAME_MODE === 'whistleblower' ? 150 : 250; 
        if(frame % rate === 0) {
            if(GAME_MODE === 'whistleblower') spawnEntity('swat');
            else spawnEntity('wb_enemy');
        }
        
        if(frame % 500 === 0) spawnItem();

        entities.forEach(e => {
            if(e.dead) return;

            // Civilians
            if(e.type === 'civ') {
                if(e.state === 'run') {
                    e.y += e.speed;
                    e.x += Math.sin(frame*0.05 + e.id)*0.5;
                    
                    // Wire Block for Civs
                    if (e.y < WIRE_Y) e.y = WIRE_Y; // Should spawn below wire anyway
                    
                    if(e.y > canvas.height + 20) {
                        e.dead = true;
                        if(GAME_MODE === 'whistleblower') {
                            score += 1;
                            spawnFloatText(e.x, canvas.height-20, "+1", "#0f0");
                        }
                    }
                }
            }
            
            // Enemies
            if(e.ai) {
                if(e.type === 'swat') {
                    // Chase Player
                    let d = dist(e, hero);
                    if(d < 400) {
                        let ang = Math.atan2(hero.y - e.y, hero.x - e.x);
                        e.angle = ang;
                        if(Math.abs(e.angle) > Math.PI / 2) e.facing = -1; else e.facing = 1;

                        if(d > 40) {
                            e.x += Math.cos(ang) * e.speed;
                            e.y += Math.sin(ang) * e.speed;
                            e.state = 'run';
                        } else {
                            e.state = 'idle';
                            if(frame % 40 === 0) damageHero(10);
                        }
                    }
                } else if (e.type === 'wb') {
                    // Enemy Whistleblower (Nerfed)
                    let d = dist(e, hero);
                    let ang = Math.atan2(hero.y - e.y, hero.x - e.x);
                    e.angle = ang;
                    if(Math.abs(e.angle) > Math.PI / 2) e.facing = -1; else e.facing = 1;

                    if(d > 250) {
                        e.x += Math.cos(ang) * e.speed;
                        e.y += Math.sin(ang) * e.speed; e.state = 'run';
                    } else if (d < 150) {
                        e.x -= Math.cos(ang) * e.speed;
                        e.y -= Math.sin(ang) * e.speed; e.state = 'run';
                    } else {
                        e.state = 'idle';
                        // Weak Flash Attack
                        if(frame % 120 === 0 && Math.random() < 0.5) {
                            e.flashTimer = 15;
                            let diff = normalizeAngle(ang - Math.atan2(hero.y - e.y, hero.x - e.x));
                            if(Math.abs(diff) < 0.5) damageHero(5); // Low Damage
                        }
                    }
                    if(e.flashTimer > 0) e.flashTimer--;
                }
            }
            // Boundary checks for AI
            if (e.y < WIRE_Y && !e.dead) e.y = WIRE_Y;
        });

        // Items
        items.forEach(i => {
            if(!i.dead && dist(hero, i) < 30) {
                if((GAME_MODE==='whistleblower' && i.type==='battery') ||
                   (GAME_MODE==='perpetrator' && i.type==='coin')) {
                    i.dead = true;
                    hero.hp = Math.min(100, hero.hp + 25);
                    spawnFloatText(hero.x, hero.y, "+HP", "#0f0");
                }
            }
        });

        // Held Entity Position
        if(hero.holding) {
            hero.holding.x = hero.x - (hero.facing * 15);
            hero.holding.y = hero.y;
            hero.holding.state = 'captured';
            hero.holding.facing = hero.facing;
        }

        // Cleanup
        entities = entities.filter(e => !e.dead);
        items = items.filter(i => !i.dead);
        particles.forEach(p => { p.x+=p.vx; p.y+=p.vy; p.life--; });
        particles = particles.filter(p => p.life > 0);
        floatTexts.forEach(t => { t.y-=0.5; t.life--; });
        floatTexts = floatTexts.filter(t => t.life > 0);

        document.getElementById('score-val').innerText = score;
    }

    // --- ACTIONS ---
    function doAction(action, e) {
        if(e) { e.preventDefault(); e.stopPropagation(); }
        if(!gameActive) return;

        if(action === 'flash' && cooldown <= 0) {
            cooldown = 25; hero.flashTimer = 8;
            entities.forEach(t => {
                if(t.type === 'swat') {
                    let d = dist(hero, t);
                    let angleTo = Math.atan2(t.y - hero.y, t.x - hero.x);
                    let diff = normalizeAngle(angleTo - hero.angle);
                    if(d < 200 && Math.abs(diff) < 0.6) {
                        t.dead = true; spawnExplosion(t.x, t.y);
                        spawnFloatText(t.x, t.y, "+1", "#fff");
                        score += 1;
                    }
                }
            });
        }
        else if (action === 'kick' && cooldown <= 0) {
            cooldown = 20; hero.swingTimer = 10;
            entities.forEach(t => {
                if(dist(hero, t) < 60 && !t.dead) {
                    if(t.type === 'wb') {
                        t.dead = true; spawnBlood(t.x, t.y);
                        score += 1; spawnFloatText(t.x, t.y, "+1", "#f00");
                    }
                    if(t.type === 'civ') {
                        t.state = 'stunned'; spawnBlood(t.x, t.y);
                        spawnFloatText(t.x, t.y, "!", "#ff0");
                    }
                }
            });
        }
        else if (action === 'grab') {
            if(hero.holding) {
                hero.holding.state = 'run'; hero.holding = null;
            } else {
                let target = null;
                entities.forEach(t => {
                    if(t.type === 'civ' && dist(hero, t) < 50 && t.y >= WIRE_Y) {
                        target = t;
                    }
                });
                if(target) { hero.holding = target; spawnFloatText(hero.x, hero.y, "GRAB", "#fff"); }
            }
        }
    }

    // --- HELPERS ---
    function spawnEntity(type) {
        let x = canvas.width/2 + (Math.random()*240 - 120);
        let e = {
            id: Math.random(), x: x, y: WIRE_Y + 10, dead: false, 
            anim: Math.random()*10, angle: Math.PI/2, facing: 1, type: type
        };
        if(type === 'civ') {
            e.color = `hsl(${Math.random()*360}, 60%, 50%)`;
            e.speed = 1 + Math.random(); e.state = 'run';
        } else if (type === 'swat') {
            e.ai = true; e.speed = 2.5; e.state = 'run';
        } else if (type === 'wb_enemy') {
            e.type = 'wb'; e.ai = true; e.speed = 1.5; e.state = 'run'; e.flashTimer = 0;
            e.hp = 1; // Dies easily
        }
        entities.push(e);
    }

    function spawnItem() {
        let type = GAME_MODE === 'whistleblower' ? 'battery' : 'coin';
        items.push({
            type: type, x: 30 + Math.random()*(canvas.width-60), 
            y: 160 + Math.random()*(canvas.height-200), life: 600, dead: false
        });
    }

    function spawnFloatText(x, y, txt, col) { floatTexts.push({x, y, txt, col, life: 60}); }
    function spawnExplosion(x,y) { for(let i=0;i<12;i++) particles.push({x, y, vx:(Math.random()-.5)*10, vy:(Math.random()-.5)*10, color:'#000', life:20, size:4}); }
    function spawnBlood(x,y) { for(let i=0;i<8;i++) particles.push({x, y, vx:(Math.random()-.5)*6, vy:(Math.random()-.5)*6, color:'#b00', life:30, size:3}); }
    function damageHero(amt) {
        hero.hp -= amt; spawnBlood(hero.x, hero.y); spawnFloatText(hero.x, hero.y, "-HP", "#f00");
        if(hero.hp <= 0) {
            gameActive = false;
            document.getElementById('go-title').innerText = "FAILED";
            document.getElementById('go-reason').innerText = GAME_MODE==='whistleblower' ? "CAPTURED" : "OVERRUN";
            document.getElementById('final-score').innerText = score;
            document.getElementById('game-over-screen').style.display = 'flex';
        }
    }
    function dist(a,b) { return Math.hypot(a.x-b.x, a.y-b.y); }
    function normalizeAngle(a) { while(a > Math.PI) a -= Math.PI*2; while(a < -Math.PI) a += Math.PI*2; return a; }

    // --- DRAWING (2D SIDE VIEW) ---
    function draw() {
        ctx.fillStyle = C.sand; ctx.fillRect(0,0,canvas.width, canvas.height);
        
        // Sand Texture
        ctx.fillStyle = C.sandDetail;
        for(let i=0; i<canvas.width; i+=40) for(let j=WIRE_Y; j<canvas.height; j+=40) 
            if((i+j)%3==0) ctx.fillRect(i, j, 4, 4);

        // Building/Wall
        ctx.fillStyle = C.wall; ctx.fillRect(0,0,canvas.width, WIRE_Y);
        ctx.fillStyle = C.door; ctx.fillRect(canvas.width/2-30, WIRE_Y-50, 60, 50);
        
        // Barbed Wire (Visual)
        ctx.strokeStyle = C.wire; ctx.lineWidth = 2; ctx.beginPath();
        ctx.moveTo(0, WIRE_Y-5); ctx.lineTo(canvas.width, WIRE_Y-5);
        for(let i=0; i<canvas.width; i+=20) {
            ctx.moveTo(i, WIRE_Y-10); ctx.lineTo(i+10, WIRE_Y);
            ctx.moveTo(i+10, WIRE_Y-10); ctx.lineTo(i, WIRE_Y);
        }
        ctx.stroke();

        // Items
        items.forEach(i => {
            ctx.save(); ctx.translate(i.x, i.y);
            if(i.type === 'battery') {
                ctx.fillStyle = '#222'; ctx.fillRect(-6,-10,12,20);
                ctx.fillStyle = '#0f0'; ctx.fillRect(-4,-5,8,12);
            } else {
                ctx.fillStyle = '#f1c40f'; ctx.beginPath(); ctx.arc(0,0,8,0,Math.PI*2); ctx.fill();
                ctx.fillStyle = '#000'; ctx.font='10px Arial'; ctx.fillText('$',-3,4);
            }
            ctx.restore();
        });

        // Shadows
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        entities.forEach(e => { ctx.beginPath(); ctx.ellipse(e.x, e.y, 10, 4, 0, 0, Math.PI*2); ctx.fill(); });
        ctx.beginPath(); ctx.ellipse(hero.x, hero.y, 12, 5, 0, 0, Math.PI*2); ctx.fill();

        // Draw Characters (Entities)
        entities.forEach(e => {
            draw2DChar(ctx, {
                type: e.type==='civ'?'civ':(e.type==='swat'?'hero_swat':'hero_wb'),
                state: e.state, facing: e.facing||1, anim: frame+e.id*10, color: e.color
            }, e.x, e.y);
            // Enemy Flash
            if(e.type==='wb' && e.flashTimer>0) drawFlash(ctx, e.x, e.y, e.angle);
        });

        // Draw Hero
        let hType = GAME_MODE==='whistleblower'?'hero_wb':'hero_swat';
        draw2DChar(ctx, {
            type: hType, state: hero.state, facing: hero.facing, anim: frame, hp: hero.hp
        }, hero.x, hero.y);

        if(hero.flashTimer > 0) drawFlash(ctx, hero.x, hero.y, hero.angle);

        // Particles
        particles.forEach(p => { ctx.fillStyle=p.color; ctx.fillRect(p.x, p.y, p.size, p.size); });
        
        // Float Text
        floatTexts.forEach(t => {
            ctx.fillStyle = t.col; ctx.font = "10px 'Press Start 2P'"; ctx.textAlign="center";
            ctx.fillText(t.txt, t.x, t.y);
        });
    }

    function drawFlash(c, x, y, ang) {
        c.save(); c.translate(x, y-15); c.rotate(ang);
        let grd = c.createLinearGradient(0, 0, 200, 0);
        grd.addColorStop(0, "rgba(255,255,255,0.8)");
        grd.addColorStop(1, "rgba(255,255,255,0)");
        c.fillStyle = grd; c.beginPath(); c.moveTo(0, 0);
        c.lineTo(200, -60); c.lineTo(200, 60); c.fill();
        c.restore();
    }

    // --- 2D SIDE VIEW RENDERER ---
    function draw2DChar(c, d, x, y) {
        c.save();
        c.translate(x, y);
        c.scale(d.facing, 1); // Flip horizontal if facing left

        // HP Bar
        if(d.hp !== undefined) {
            c.save(); c.scale(d.facing, 1); // unflip text
            c.fillStyle = 'red'; c.fillRect(-15, -50, 30, 4);
            c.fillStyle = '#0f0'; c.fillRect(-15, -50, 30*(d.hp/100), 4);
            c.restore();
        }

        let run = (d.state === 'run' || d.state === 'run_hold') ? Math.sin(d.anim * 0.3) : 0;

        // Legs
        c.strokeStyle = '#222'; c.lineWidth = 4;
        c.beginPath();
        c.moveTo(-4, -15); c.lineTo(-8 - (run*6), 0); // Back leg
        c.moveTo(4, -15); c.lineTo(8 + (run*6), 0); // Front leg
        c.stroke();

        // Body
        if(d.type === 'civ') {
            c.fillStyle = d.color; c.fillRect(-6, -28, 12, 16);
            c.fillStyle = C.skin; c.fillRect(-5, -36, 10, 8); // Head
        } 
        else if (d.type === 'hero_wb') {
            c.fillStyle = C.wbBlue; c.fillRect(-6, -28, 12, 16); // Vest
            c.fillStyle = '#fff'; c.fillRect(-4, -28, 8, 4); // Scarf/Shirt
            c.fillStyle = C.skin; c.fillRect(-5, -36, 10, 8); // Head
            c.fillStyle = '#111'; c.fillRect(-6, -38, 12, 4); // Hair
            // Holding Camera
            c.fillStyle = '#222'; c.fillRect(4, -22, 8, 6);
        }
        else if (d.type === 'hero_swat') {
            c.fillStyle = C.swatBlack; c.fillRect(-7, -28, 14, 16); // Armor
            c.fillStyle = '#111'; c.beginPath(); c.arc(0, -32, 6, 0, Math.PI*2); c.fill(); // Helmet
            c.fillStyle = C.swatRed; c.fillRect(2, -34, 6, 2); // Visor side
            
            // Baton Swing
            if(d.type === 'hero_swat' && hero.swingTimer>0 && d.hp !== undefined) {
                c.save(); c.translate(6, -22); c.rotate(Math.sin(hero.swingTimer)*2);
                c.fillStyle = '#333'; c.fillRect(0, -20, 3, 25);
                c.restore();
            } else {
                // Holding Baton
                c.fillStyle = '#333'; c.fillRect(4, -24, 2, 12);
            }
        }
        
        c.restore();
    }
</script>
</body>
</html>
