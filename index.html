<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Safe The Uyghurs</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #111;
            font-family: 'Press Start 2P', cursive;
            touch-action: none;
        }

        canvas {
            display: block;
            margin: 0 auto;
            background-color: #dcb159; /* Richer Sand Color */
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        /* UI LAYOUT */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        #top-ui {
            padding: 15px;
            display: flex;
            justify-content: space-between;
            color: #fff;
            text-shadow: 2px 2px 0 #000;
            font-size: 14px;
        }

        /* SCREENS */
        #start-screen, #game-over-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(18, 24, 33, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            z-index: 10;
            pointer-events: auto;
            text-align: center;
        }

        h1 { 
            font-size: 28px; 
            color: #ffcc00; 
            margin-bottom: 10px; 
            line-height: 1.4;
            text-shadow: 4px 4px 0 #8b0000;
        }
        
        p { 
            font-size: 10px; 
            color: #ccc; 
            line-height: 1.8; 
            max-width: 80%; 
            margin-bottom: 20px;
        }

        .btn {
            background: #d32f2f;
            border: 4px solid #fff;
            padding: 15px 30px;
            color: white;
            font-family: 'Press Start 2P';
            font-size: 16px;
            cursor: pointer;
            transition: transform 0.1s;
        }
        .btn:active { transform: scale(0.95); }

        /* CONTROLS OVERLAY */
        .controls-hint {
            display: flex;
            width: 100%;
            height: 180px;
            pointer-events: none;
            position: absolute;
            bottom: 0;
        }
        .left-control { 
            width: 50%; 
            background: radial-gradient(circle at center, rgba(255,255,255,0.1) 0%, transparent 60%);
        }
        .right-control { 
            width: 50%; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
        }
        .flash-btn-vis { 
            width: 80px; height: 80px; 
            border-radius: 50%; 
            border: 4px solid rgba(255,255,255,0.8); 
            background: rgba(255,255,255,0.1); 
            display: flex; align-items: center; justify-content: center;
        }
        .flash-icon {
            width: 40px; height: 30px; border: 2px solid white; background: #fff;
        }

    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="top-ui">
            <span>SAVED: <span id="score-val">0</span></span>
            </div>
        <div class="controls-hint">
            <div class="left-control"></div>
            <div class="right-control">
                <div class="flash-btn-vis"><div class="flash-icon"></div></div>
            </div>
        </div>
    </div>

    <div id="start-screen">
        <h1>SAFE THE<br>UYGHURS</h1>
        <p>THEY ARE FLEEING THE CAMP.<br>YOU ARE THEIR ONLY WITNESS.</p>
        <p style="color: #4fc3f7">CONTROLS:<br>LEFT: Drag to Move<br>RIGHT: Tap to Flash Camera</p>
        <button class="btn" onclick="startGame()">START MISSION</button>
    </div>

    <div id="game-over-screen" style="display: none;">
        <h1 id="go-title" style="color: #ff5555">CAPTURED</h1>
        <p id="go-reason">The truth was silenced.</p>
        <p>Total Saved: <span id="final-score">0</span></p>
        <button class="btn" onclick="resetGame()">RETRY</button>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
    /** * GAME ENGINE & LOGIC 
     */
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // Fit to screen
    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // --- CONFIGURATION ---
    const C = {
        sand: '#dcb159',
        sandDetail: '#cba048',
        wall: '#3b434e',
        wallDark: '#232830',
        door: '#1a1a1a',
        wire: '#111',
        heroSkin: '#ffdbac',
        heroVest: '#55aaff', // UN Blue
        heroPants: '#333',
        swatColor: '#000',
        swatVest: '#1a1a1a',
        swatVisor: '#cc0000',
        flash: 'rgba(255, 255, 255, 0.85)'
    };

    // --- STATE VARIABLES ---
    let gameActive = false;
    let frame = 0;
    let score = 0;
    let flashCooldown = 0;
    
    // Controls
    let joystick = { on: false, id: null, sx: 0, sy: 0, cx: 0, cy: 0 };
    let inputs = { dx: 0, dy: 0, flash: false };

    // Entities
    let hero = { 
        x: 0, y: 0, speed: 4, 
        hp: 100, maxHp: 100, 
        facing: 1, // 1 = right, -1 = left
        state: 'idle', // idle, run, captured
        capturedBy: null
    };
    
    let entities = []; // Civilians + Enemies
    let particles = [];
    let flashes = [];

    // --- INPUT HANDLERS ---
    canvas.addEventListener('touchstart', ts, {passive: false});
    canvas.addEventListener('touchmove', tm, {passive: false});
    canvas.addEventListener('touchend', te, {passive: false});
    
    // PC Debugging
    const keys = {};
    window.addEventListener('keydown', e => { keys[e.code] = true; if(e.code==='Space') fireFlash(); });
    window.addEventListener('keyup', e => keys[e.code] = false);

    function ts(e) {
        e.preventDefault();
        for(let t of e.changedTouches) {
            if(t.clientX < canvas.width/2) {
                joystick.on = true; joystick.id = t.identifier;
                joystick.sx = t.clientX; joystick.sy = t.clientY;
                joystick.cx = t.clientX; joystick.cy = t.clientY;
            } else {
                fireFlash();
            }
        }
    }
    function tm(e) {
        e.preventDefault();
        for(let t of e.changedTouches) {
            if(joystick.on && t.identifier === joystick.id) {
                joystick.cx = t.clientX; joystick.cy = t.clientY;
            }
        }
    }
    function te(e) {
        e.preventDefault();
        for(let t of e.changedTouches) {
            if(joystick.on && t.identifier === joystick.id) {
                joystick.on = false;
            }
        }
    }

    // --- GAME LOOP ---
    function startGame() {
        document.getElementById('start-screen').style.display = 'none';
        document.getElementById('game-over-screen').style.display = 'none';
        
        // Reset State
        hero.x = canvas.width/2;
        hero.y = canvas.height - 150;
        hero.hp = 100;
        hero.state = 'idle';
        hero.capturedBy = null;
        score = 0;
        entities = [];
        particles = [];
        gameActive = true;
        
        requestAnimationFrame(loop);
    }

    function resetGame() { startGame(); }

    function loop() {
        if(!gameActive) return;
        update();
        draw();
        frame++;
        requestAnimationFrame(loop);
    }

    // --- LOGIC ---
    function update() {
        if(flashCooldown > 0) flashCooldown--;

        // 1. Hero Movement
        inputs.dx = 0; inputs.dy = 0;
        
        if(hero.state !== 'captured') {
            // Joystick logic
            if(joystick.on) {
                let dx = joystick.cx - joystick.sx;
                let dy = joystick.cy - joystick.sy;
                let dist = Math.sqrt(dx*dx + dy*dy);
                if(dist > 5) {
                    let angle = Math.atan2(dy, dx);
                    inputs.dx = Math.cos(angle) * hero.speed;
                    inputs.dy = Math.sin(angle) * hero.speed;
                }
            } 
            // Keyboard logic
            else {
                if(keys['ArrowUp'] || keys['KeyW']) inputs.dy = -hero.speed;
                if(keys['ArrowDown'] || keys['KeyS']) inputs.dy = hero.speed;
                if(keys['ArrowLeft'] || keys['KeyA']) inputs.dx = -hero.speed;
                if(keys['ArrowRight'] || keys['KeyD']) inputs.dx = hero.speed;
            }

            hero.x += inputs.dx;
            hero.y += inputs.dy;
            
            // Bounds
            if(hero.x < 15) hero.x = 15;
            if(hero.x > canvas.width - 15) hero.x = canvas.width - 15;
            if(hero.y < 130) hero.y = 130; // Barbed wire limit
            if(hero.y > canvas.height - 15) hero.y = canvas.height - 15;

            // Direction & State
            if(inputs.dx > 0) hero.facing = 1;
            if(inputs.dx < 0) hero.facing = -1;
            hero.state = (inputs.dx !== 0 || inputs.dy !== 0) ? 'run' : 'idle';
        }

        // 2. Spawn Logic
        // Civilians
        if(frame % 120 === 0) spawnCivilian();
        // Enemies (Ramp up difficulty)
        let rate = Math.max(50, 180 - (score/2));
        if(frame % Math.floor(rate) === 0) spawnSwat();

        // 3. Entity Updates
        entities.forEach(e => {
            if(e.dead) return;

            // --- CIVILIAN LOGIC ---
            if(e.type === 'civ') {
                if(e.state === 'run') {
                    e.y += e.speed;
                    // Jitter
                    if(frame % 20 === 0 && Math.random() > 0.5) e.dx = (Math.random()-0.5) * 2;
                    e.x += e.dx;
                    
                    if(e.y > canvas.height + 20) {
                        e.dead = true;
                        score += 100;
                        document.getElementById('score-val').innerText = score;
                    }
                }
            }

            // --- SWAT LOGIC ---
            if(e.type === 'swat') {
                // If dragging someone
                if(e.state === 'drag_civ' || e.state === 'drag_hero') {
                    // Move back to door
                    let doorX = canvas.width/2;
                    let doorY = 100;
                    let ang = Math.atan2(doorY - e.y, doorX - e.x);
                    e.x += Math.cos(ang) * (e.speed * 0.7);
                    e.y += Math.sin(ang) * (e.speed * 0.7);

                    // Sync Victim Position
                    if(e.target) {
                        e.target.x = e.x + (Math.sin(frame*0.2)*5); // dangle effect
                        e.target.y = e.y + 10;
                    }

                    // Reached Door
                    if(e.y < 120) {
                        e.dead = true;
                        if(e.target) e.target.dead = true;
                        if(e.state === 'drag_hero') triggerGameOver("CAPTURED");
                    }
                    return; // Skip hunting logic
                }

                // HUNTING LOGIC
                let target = null;
                let minDist = 1000;

                // Priority 1: Check Hero proximity (Aggression)
                let distToHero = Math.hypot(hero.x - e.x, hero.y - e.y);
                if(distToHero < 100 && hero.state !== 'captured') {
                    target = hero;
                    e.targetType = 'hero';
                } else {
                    // Priority 2: Nearest Civilian
                    e.targetType = 'civ';
                    entities.forEach(civ => {
                        if(civ.type === 'civ' && civ.state === 'run') {
                            let d = Math.hypot(civ.x - e.x, civ.y - e.y);
                            if(d < minDist) { minDist = d; target = civ; }
                        }
                    });
                }

                if(target) {
                    let ang = Math.atan2(target.y - e.y, target.x - e.x);
                    e.x += Math.cos(ang) * e.speed;
                    e.y += Math.sin(ang) * e.speed;
                    e.facing = (Math.cos(ang) > 0) ? 1 : -1;

                    // Attack/Grab Collision
                    if(Math.hypot(target.x - e.x, target.y - e.y) < 20) {
                        if(e.targetType === 'civ') {
                            e.state = 'drag_civ';
                            e.target = target;
                            target.state = 'captured';
                        } else if (e.targetType === 'hero') {
                            // Hit the hero
                            if(frame % 30 === 0) { // Attack cooldown
                                hero.hp -= 34; // 3 hits to die
                                spawnBlood(hero.x, hero.y);
                                if(hero.hp <= 0) {
                                    hero.hp = 0;
                                    hero.state = 'captured';
                                    e.state = 'drag_hero';
                                    e.target = hero;
                                    hero.capturedBy = e;
                                }
                            }
                        }
                    }
                } else {
                    // Patrol
                    e.y += 1;
                }
            }
        });

        // Cleanup
        entities = entities.filter(e => !e.dead);
        
        // Particles
        particles.forEach(p => { p.x+=p.vx; p.y+=p.vy; p.life--; });
        particles = particles.filter(p => p.life > 0);
    }

    // --- ACTIONS ---
    function fireFlash() {
        if(!gameActive || flashCooldown > 0 || hero.state === 'captured') return;
        
        flashCooldown = 40;
        
        // Spawn Visual Flash
        flashes.push({x: hero.x, y: hero.y, life: 5, facing: hero.facing});

        // Check Hits (Cone)
        entities.forEach(e => {
            if(e.type === 'swat') {
                let dx = e.x - hero.x;
                let dy = e.y - hero.y;
                let dist = Math.sqrt(dx*dx + dy*dy);
                
                // Direction check
                let validDir = false;
                if(hero.facing === 1 && dx > 0) validDir = true;
                if(hero.facing === -1 && dx < 0) validDir = true;
                // Vertical tolerance
                if(Math.abs(dx) < 20) validDir = true; // Close enough

                if(dist < 150 && validDir) {
                    // HIT!
                    e.dead = true;
                    score += 50;
                    document.getElementById('score-val').innerText = score;
                    spawnPixelExplosion(e.x, e.y);

                    // Free victim if dragging
                    if(e.target) {
                        e.target.state = (e.target === hero) ? 'idle' : 'run';
                        if(e.target === hero) hero.capturedBy = null;
                        e.target = null;
                    }
                }
            }
        });
    }

    function spawnCivilian() {
        entities.push({
            type: 'civ',
            x: canvas.width/2 + (Math.random()*40-20),
            y: 110,
            color: `hsl(${Math.random()*360}, 70%, 50%)`,
            speed: 1.5 + Math.random(),
            dx: 0,
            state: 'run',
            dead: false,
            animOffset: Math.random() * 10
        });
    }

    function spawnSwat() {
        entities.push({
            type: 'swat',
            x: canvas.width/2 + (Math.random()*60-30),
            y: 110,
            speed: 2.2 + (score/1000),
            state: 'hunt',
            dead: false,
            target: null,
            facing: 1,
            animOffset: Math.random() * 10
        });
    }

    function spawnPixelExplosion(x, y) {
        for(let i=0; i<20; i++) {
            particles.push({
                x: x, y: y,
                vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10,
                color: '#000', life: 20, size: 4
            });
        }
    }

    function spawnBlood(x, y) {
        for(let i=0; i<10; i++) {
            particles.push({
                x: x, y: y - 10,
                vx: (Math.random()-0.5)*5, vy: (Math.random()-0.5)*5,
                color: '#ff0000', life: 30, size: 3
            });
        }
    }

    function triggerGameOver(reason) {
        gameActive = false;
        document.getElementById('go-title').innerText = reason;
        document.getElementById('go-reason').innerText = reason === "CAPTURED" ? "You were taken to the camp." : "You were killed in action.";
        document.getElementById('final-score').innerText = score;
        document.getElementById('game-over-screen').style.display = 'flex';
    }

    // --- DRAWING ---
    function draw() {
        // Background
        ctx.fillStyle = C.sand;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Sand Texture (Dots)
        ctx.fillStyle = C.sandDetail;
        for(let i=0; i<canvas.width; i+=40) {
            for(let j=130; j<canvas.height; j+=40) {
                if((i+j)%3===0) ctx.fillRect(i, j, 4, 4);
            }
        }

        // --- TOP AREA ---
        ctx.fillStyle = C.wall;
        ctx.fillRect(0, 0, canvas.width, 120);
        
        // Door
        ctx.fillStyle = C.door;
        ctx.fillRect(canvas.width/2 - 30, 70, 60, 50);

        // Barbed Wire
        ctx.strokeStyle = C.wire;
        ctx.lineWidth = 2;
        ctx.beginPath();
        // Coils
        for(let i=-20; i<canvas.width; i+=15) {
            ctx.arc(i, 120, 10, 0, Math.PI*2);
        }
        ctx.stroke();

        // Shadows
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        entities.forEach(e => {
            if(e.dead) return;
            ctx.beginPath();
            ctx.ellipse(e.x, e.y, 10, 4, 0, 0, Math.PI*2);
            ctx.fill();
        });
        ctx.beginPath();
        ctx.ellipse(hero.x, hero.y, 12, 5, 0, 0, Math.PI*2);
        ctx.fill();

        // Entities
        entities.forEach(e => {
            if(e.dead) return;
            if(e.type === 'civ') drawCivilian(e);
            if(e.type === 'swat') drawSwat(e);
        });

        // Hero
        drawHero();

        // Flash Effect
        flashes.forEach(f => {
            ctx.save();
            ctx.translate(f.x, f.y - 15);
            ctx.fillStyle = C.flash;
            ctx.globalAlpha = f.life / 5;
            
            ctx.beginPath();
            ctx.moveTo(0,0);
            if(f.facing === 1) { // Right
                ctx.lineTo(200, -80); ctx.lineTo(200, 80);
            } else { // Left
                ctx.lineTo(-200, -80); ctx.lineTo(-200, 80);
            }
            ctx.fill();
            ctx.restore();
            f.life--;
        });
        flashes = flashes.filter(f => f.life > 0);

        // Particles
        particles.forEach(p => {
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x, p.y, p.size, p.size);
        });
    }

    // --- SPRITE PAINTERS ---
    
    // Helper to draw limbs based on running phase
    function getLimbPos(entity) {
        if(entity.state === 'run' || entity.state === 'hunt') {
            let t = (frame + entity.animOffset) * 0.3;
            return Math.sin(t) * 8;
        }
        return 0;
    }

    function drawCivilian(c) {
        ctx.save();
        ctx.translate(c.x, c.y);
        
        let swing = getLimbPos(c);

        // Legs
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(-4, -10); ctx.lineTo(-4 + swing, 0);
        ctx.moveTo(4, -10); ctx.lineTo(4 - swing, 0);
        ctx.stroke();

        // Body
        ctx.fillStyle = c.color;
        ctx.fillRect(-7, -22, 14, 14);

        // Head
        ctx.fillStyle = C.heroSkin; // Generic skin
        ctx.fillRect(-5, -30, 10, 8);

        // Arms (swinging opposite to legs)
        ctx.fillStyle = c.color;
        ctx.fillRect(-10, -22 + swing, 3, 10);
        ctx.fillRect(7, -22 - swing, 3, 10);

        ctx.restore();
    }

    function drawSwat(s) {
        ctx.save();
        ctx.translate(s.x, s.y);
        let f = s.facing;
        let swing = getLimbPos(s);

        // Legs (Black)
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 5;
        ctx.beginPath();
        ctx.moveTo(-4, -10); ctx.lineTo(-4 + swing, 0);
        ctx.moveTo(4, -10); ctx.lineTo(4 - swing, 0);
        ctx.stroke();

        // Body (Armor)
        ctx.fillStyle = C.swatVest;
        ctx.fillRect(-8, -24, 16, 16); // Bulky

        // Head (Helmet)
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(0, -28, 7, 0, Math.PI*2);
        ctx.fill();

        // Visor (Red Eye)
        ctx.fillStyle = C.swatVisor;
        ctx.fillRect(f*2, -30, f*6, 3);

        // Baton/Weapon
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(f*8, -18); ctx.lineTo(f*8, -8 - swing);
        ctx.stroke();

        ctx.restore();
    }

    function drawHero() {
        if(hero.hp <= 0 && hero.state !== 'captured') return; // Dead and not being dragged yet
        
        ctx.save();
        ctx.translate(hero.x, hero.y);
        let f = hero.facing;
        let swing = 0;
        if(hero.state === 'run') swing = Math.sin(frame*0.3)*8;

        // Health Bar
        if(hero.hp < 100) {
            ctx.fillStyle = 'red';
            ctx.fillRect(-15, -50, 30, 5);
            ctx.fillStyle = '#0f0';
            ctx.fillRect(-15, -50, 30 * (hero.hp/100), 5);
        }

        // Legs
        ctx.strokeStyle = C.heroPants;
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(-4, -10); ctx.lineTo(-4 + swing, 0);
        ctx.moveTo(4, -10); ctx.lineTo(4 - swing, 0);
        ctx.stroke();

        // Body (UN Vest)
        ctx.fillStyle = '#fff'; // Shirt
        ctx.fillRect(-7, -22, 14, 14);
        ctx.fillStyle = C.heroVest; // Vest
        ctx.fillRect(-8, -22, 16, 10);

        // Head
        ctx.fillStyle = C.heroSkin;
        ctx.fillRect(-5, -32, 10, 10);
        // Hair
        ctx.fillStyle = '#444';
        ctx.fillRect(-6, -35, 12, 4);

        // Camera
        ctx.fillStyle = '#111';
        ctx.fillRect(f*4, -20, 8, 6); // Body
        ctx.fillStyle = '#eee'; // Lens
        ctx.beginPath();
        ctx.arc(f*12, -17, 3, 0, Math.PI*2);
        ctx.fill();

        ctx.restore();
    }

</script>
</body>
</html>
